#!/usr/bin/env ruby

# Copyright 2014 Shawn Neal <sneal@sneal.net>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

$:.push File.expand_path('../../lib', __FILE__)

require 'readline'
require 'optparse'
require 'winrm'

def parse_options
  options = {}
  options[:auth_type] = :plaintext
  options[:basic_auth_only] = true
  options[:mode] = :repl

  optparse = OptionParser.new do |opts|
    opts.banner = "Usage: rwinrm [command] [local_path] [remote_path] endpoint [options]"
    opts.separator  ""
    opts.separator  "Commands"
    opts.separator  "     repl(default)"
    opts.separator  "     upload"
    opts.separator  ""
    opts.separator  "Options"

    opts.on('-u', '--user username', String, 'WinRM user name') do |v|
      options[:user] = v
    end

    opts.on('-p', '--pass password', String, 'WinRM user password') do |v|
      options[:pass] = v
    end

    opts.on('-h', '--help', 'Display this screen') do
      puts optparse
      exit
    end
  end

  optparse.parse!

  if ARGV[0] && ARGV[0].downcase !~ /\A#{URI::regexp(['http', 'https'])}\z/
    options[:mode] = ARGV.shift.downcase.to_sym

    case options[:mode]
    when :upload
      options[:local_path] = ARGV.shift
      options[:remote_path] = ARGV.shift

      raise OptionParser::MissingArgument.new(:local_path) if options[:local_path].nil?
      raise OptionParser::MissingArgument.new(:remote_path) if options[:remote_path].nil?
    when :repl
    else
      raise OptionParser::InvalidArgument.new(options[:mode])
    end
  end
  options[:endpoint] = ARGV.shift

  raise OptionParser::MissingArgument.new(:endpoint) if options[:endpoint].nil?

  options
rescue OptionParser::InvalidOption, OptionParser::MissingArgument, OptionParser::InvalidArgument
  puts $!.message
  puts optparse
  exit 1
end

def winrm_client(options)
  WinRM::WinRMWebService.new(
      options[:endpoint],
      options[:auth_type].to_sym,
      options)
end

def upload(client, options)
  bytes = WinRM::FileTransfer.upload(client, options[:local_path], options[:remote_path])
  shell_id = client.open_shell()
  puts "#{bytes} total bytes transfered"
end

def repl(client, options)
  shell_id = client.open_shell()
  command_id = client.run_command(shell_id, 'cmd')

  read_thread = Thread.new do
    client.get_command_output(shell_id, command_id) do |stdout, stderr|
      STDOUT.write stdout
      STDERR.write stderr
    end
  end

  while buf = Readline.readline('', true)
    if buf =~ /^exit/
      read_thread.exit()
      client.cleanup_command(shell_id, command_id)
      client.close_shell(shell_id)
      exit 0
    else
      client.write_stdin(shell_id, command_id, "#{buf}\r\n")
    end
  end
end

def run(options)
  client = winrm_client(options)
  method(options[:mode]).call(client, options)
  exit 0
rescue Interrupt
  # ctrl-c
rescue StandardError => e
  puts e.message
  exit 1
end

run(parse_options())
